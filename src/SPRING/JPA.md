# JPA

**JPA**란 자바 진영에서 **ORM 기술 표준**으로 사용되는 인터페이스의 모음이다.

즉, 실제적으로 구현된 것이 아니라 구현된 클래스와 매핑을 해주기 위해 사용되는 프레임워크이다.

JPA를 구현한 대표적인 오픈소스로는 Hibernate가 있다.

Java 애플리케이션과 JDBC API 사이에서 동작, 인터페이스로 구성되어 있음

>ORM(Object-Relation Mapping)
> 
> 애플리케이션의 Class와 RDB의 테이블을 매핑(연결) 한다는 뜻이며, 기술적으로는
> 
> 애플리케이션의 객체를 RDB 테이블에 자동으로 영속화 해주는 것이라고 보면 된다.
> 
> 

## 장점

- SQL문이 아닌 Method를 통해 DB를 조작할 수 있어, 개발자는 객체 모델을 이용하여 비즈니스 로직을 구성하는데만 집중할 수 있다.


- Query와 같이 필요한 선언문, 할당 등의 부수적인 코드가 줄어들어, 각종 객체에 대한 코드를 별도로 작성하여 코드의 가독성을 높임


- 객체지향적인 코드 작성이 가능하다. 오직 객체지향적 접근만 고려하면 되기 때문에 생산성 증가


- 매핑하는 정보가 Class로 명시 되었기 때문에 ERD를 보는 의존도를 낮출 수 있고 유지보수 및 리팩토링에 유리


- DB를 변경하게 될 경우 ORM을 사용한다면 쿼리를 수정할 필요가 없다

## 단점

- 프로젝트의 규모가 크고 복잡하여 설계가 잘못된 경우, 속도 저하 및 일관성을 무너뜨리는 문제점이 생길 수 있다.


- 복잡하고 무거운 Query는 속도를 위해 별도의 튜닝이 필요하기 때문에 결국 SQL문을 사용해야 할 수 있음


- 학습비용이 비쌈

## 동작과정

- JPA는 애플리케이션과 JDBC 사이에서 동작한다.
  - 개발자가 JPA를 사용하면 JPA 내부에서 JDBC API를 사용하여 SQL을 호출하여 DB와 통신한다.
  - 즉, 개발자가 직접 JDBC API를 사용하는것이 아니다.

### 저장과정

- MemberDAO에서 객체를 저장하고 싶을 때
- 개발자는 JPA에 Member 객체를 넘긴다
- JPA는
  - Member 엔티티를 분석
  - Insert SQL 생성
  - JDBC API를 사용해서 SQL을 DB에 날린다.

### 조회 과정

- Member 객체를 조회하고 싶을 때
- 개발자는 member의 pk 값을 JPA에 넘긴다
- JPA는
  - 엔티티의 매핑 정보를 바탕으로 적절한 SELECT SQL을 생성
  - JDBC API를 사용하여 SQL을 DB에 날림
  - DB로부터 결과를 받아옴
  - 결과를 객체에 모두 매핑




## 기능 및 장단점

### 더티 체킹(Dirty Checking)

JPA는 영속 상태에 있는 엔티티의 변경을 자동으로 감지한다.

그래서 개발자가 데이터를 변경 후 별도의 저장 메서드를 호출할 필요가 없다.

트랜잭션이 커밋될 때, 변경된 엔티티를 자동으로 데이터베이스에 반영한다

```java
    @Transactional
    public void update(Long boardId, BoardRequestDto dto) {
        //
        Board board = boardRepository.findById(boardId)
        .orElseThrow(() -> new CustomBoardException(BOARD_NOT_FOUND));
        
        board.update(dto.getTitle(), dto.getContent());
    }
```

### 쓰기지연 SQL 저장소(Write-behind caching) 

JPA는 트랜잭션 커밋 시점에 필요한 SQL을 모아 한 번에 데이터베이스에 전송한다.

이를 통해 네트워크 사용량과 데이터베이스 액세스를 최적화 할 수 있다.

### 1차 캐시와 동일성 보장 

JPA는 1차캐시를 통해 이미 로드된 엔티티를 관리하므로, 같은 트랜잭션 내에서는 동일한 엔티티에 대한

동일성이 보장된다.

### 캐시 기능

JPA는 1차 캐시뿐만 아니라 2차 캐시도 제공하여 성능향상에 기여한다.


# 영속성 컨텍스트

JPA를 이해하는데 가장 중요한 언어다.

**엔티티를 영구 저장하는 환경**이라는 뜻으로

엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.

영속성 컨텍스트는 논리적인 개념에 가깝기 때문에 눈에 보이지 않는다.

엔티티 매니저를 생성할 때 하나 만들어진다.

## 엔티티의 생명주기

- 비영속(new / transient) : 영속성 컨텍스트와 전혀 관계가 없는 상태
- 영속(managed) : 영속성 컨텍스트에 저장된 상태
- 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제(removed) : 삭제된 상태

### 비영속

엔티티 객체를 생성, 순수한 객체 상태이며, 아직 저장하지 않은 상태

따라서 영속성 컨텍스트나 DB와는 전혀 관련이 없다. 이를 비영속 상태라 한다.

```java
    Member member = new Member();
    memner.setId("test");
    member.setName("tName");
```

### 영속

엔티티 매니저를 통해서 엔티티를 영속성 컨텍스트에 저장했다.

영속성 컨텍스트가 관리하는 엔티티를 역송 상태라고 한다.

영속 상태라는 것은 영속성 컨텍스트에 의해 관리 된다는 뜻

```java
    em.persist(member);
    //
    Membmer member = memberRepository.save(member);
```

### 준영속

영속성 컨텍스트가 관리하던 영속 상태의 엔티티틀 영속성 컨텍스트가 관리하지 않으면 준영속 상태가 된다.

em.detach(), em.close(), em.clear()를 호출하게되면 준영속 상태로 돌아게게 됨

하지만 많이 사용하는 Spring Data Jpa 환경에서는 개발자가 직접 detach()나 clear()를 사용할 일이 드믈다.

그 이유는 대부분의 작업이 트랜잭션 내에서 일어나기 때문인데 트랜잭션이 종료되면 자동으로 영속성 컨텍스트가 닫히기 때문이다.

### 삭제

엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한다

```java
em.remove(member);

memberRepository.delete(member);
```

## 영속성 컨텍스트의 특징

### 영속성 컨텍스트와 식별자 값

영속성 컨텍스트는 엔티티를 식별자 값(@Id로 테이블의 기본키와 매핑한 값)으로 구분한다

따라서 **영속 상태는 식별자 값이 반드시 있어야 한다**.

식별자 값이 없다면 예외가 발생한다.

### 영속성 컨텍스트와 데이터베이스 저장

JPA는 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티리를 데이터베이스에 반영하는데

이것을 flush라고 한다.

### 영속성 컨텍스트가 엔티티틀 관리하게 될 때의 장점

- 1차캐시
- 동일성 보장
- 트랜잭션을 지원하는 쓰기 지연
- 변경 감지
- 지연 로딩

### 엔티티 조회

영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이것을 1차 캐시라고 한다.

영속 상태의 엔티티는 모두 이곳에 저장된다.

쉽게 말해 영속성 컨텍스트 내부에 Map 하나 있는데 키는 @Id로 매핑한 식별자고 값은 엔티티 인스턴스다.

```java
Memeber member = new Member();
member.setId("member1");
member.setName("name1");

em.persist(member);
```

코드를 실행하면 1차 캐시에 회원 엔티티를 저장한다

회원 엔티티는 아직 데이터베이스에 저장되지 않은 상태다.


**1차캐시**

|@Id|Entity|
|---|------|
|member1|member|

1차캐시의 키는 식별자 값이고, 식별자 값은 데이터베이스의 기본키와 매핑되어 있다.

영속성 컨텍스트에 데이터를 저장하고 조회하는 모든 기준은 **데이터베이스 기본 키 값**이다.

### 1차 캐시에서 조회

em.find()를 호출하면 **우선 1차 캐시에서 식별자 값으로 엔티티를 찾는다**.

만약 엔티티가 있으면 데이터베이스를 조회하지 않고 메모리에 있는 1차 캐시에서 엔티티를 조회한다.

만약 em.find()를 호출했는데 엔티티가 1차 캐시에 없다면?

엔티티 매니저는 DB를 조회해서 엔티티를 생성하고, 1차 캐시에 저장한 후에 영속 상태의 엔티티를 반환한다.

이런점으로 인해 성능상 이점을 누릴 수 있다.

### 영속 엔티티의 동일성 보장

```java
Member a = em.find(Member.class, "member1");
Member b = em.find(Member.class, "member1");

a == b 는 참일까 거짓일까?
```

em.find(Member.class, "member1")를 반복해서 호출해도 영속성 컨텍스트는 1차 캐시에 있는

같은 엔티티 인스턴스를 반환한다.

따라서 둘은 같은 인스턴스고 값은 참이다.

따라서 **영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장한다**.


### 엔티티 등록
```java
// 트랜잭션 시작
tx.begin();

em.persist(memberA);
em.persist(memberB);
// 여기까지는 INSERT SQL을 DB에 보내지 않는다.

// 커밋하는 순간 데이터베이스에 INSERT SQL을 보낸다
tx.commit();
```

엔티티 매니저는 트랜잭션을 커밋하기 직전까지 DB에 엔티티를 저장하지 않고

내부 쿼리 저장소(쓰기 지연 SQL 저장소)에 SQL을 차곡차곡 모아둔다

그리고 트랜잭션을 커밋할 때 모아둔 쿼리를 DB에 보내는데 이것을

**트랜잭션을 지원하는 쓰기 지연**이라 한다.

em.persist(member)를 호출하는 수간 1차 캐시에 회원 엔티티를 저장하면서 쿼리를 만들어

쓰기 지연 SQL 저장소에 보관한다.

tx.commit() 트랜잭션 커밋을 하면 엔티티매니저는 일단 영속선 컨텍스트를 플러시 한다.

플러시를 하면 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화 하는 작업이 이뤄진다.

이 때 등록, 수정, 삭제한 엔티티를 데이터베이스에 반영한다.

### 엔티티 수정
